# This the Makefile fragment to be included by SDK, Projects and UnitTests Makefiles
#
# Makefile inputs:
# PROJECT_NAME    same as directory name
# PROJECT_TYPE    lib or app
# PROJECT_FILES   all files or wildcard like *.cpp
# SDK_DEPS        needed library names in SDK/
# EXT_DEPS        external libraries, like gtk got GTK+
# INCDIRS         additional include directories
#
# Command line options:
# (default)       builds all with debug configuration
# CONFIG=release  builds all with release configuration
# CONFIG=coverage builds all with coverage configuration
# clean           cleans current project and its dependencies
# rebuild         cleans then builds
# run             runs the application
# cov             creates coverage files. make CONFIG=coverage should have been called

INCDIRS += ../../sdk
CONFIG ?= debug
OUTDIR := linux-$(CONFIG)

GCC := gcc
GPP := g++
LD  := ld
OBJCOPY := objcopy

CFLAGS := -Wall
CFLAGS += -fdata-sections -ffunction-sections -fvisibility=hidden
LDFLAGS := --gc-sections,--no-export-dynamic
EXTLIBS := -pthread -lrt

# In Debug, store debug symbols (-g)
# In Release, optimize and strip symbols with the linker
ifeq ($(CONFIG),debug)
	CFLAGS += -g
else ifeq ($(CONFIG),release)
	CFLAGS += -O2 -Werror
	LDFLAGS := $(LDFLAGS),-s
else ifeq ($(CONFIG),coverage)
	CFLAGS += -g -fprofile-arcs -ftest-coverage
	EXTLIBS += -lgcov
else
$(error Bad CONFIG value)
endif

CPPFLAGS := $(CFLAGS) -Wextra
CPPFLAGS += -std=c++0x $(addprefix -I,$(INCDIRS))

# Most includes for GTK+ are in /usr/include but some of them are
# very specific. pkg-config gives us all the needed paths.
ifeq ($(EXT_DEPS),gtk)
	CPPFLAGS += $(shell pkg-config --cflags gtk+-3.0)
	EXTLIBS += $(shell pkg-config --libs gtk+-3.0)
endif

ifeq ($(PROJECT_TYPE), lib)
	OUTPATH := $(OUTDIR)/lib$(PROJECT_NAME).a
else
	OUTPATH := $(OUTDIR)/$(PROJECT_NAME)
	SDK_DIRS := $(addprefix ../../sdk/,$(SDK_DEPS))
	SDK_LIBDIRS := $(addsuffix /linux-$(CONFIG)/,$(SDK_DIRS))
	SDK_LIBNAMES := $(addprefix lib,$(SDK_DEPS))
	SDK_LIBNAMES := $(addsuffix .a,$(SDK_LIBNAMES))
	SDK_LIBPATHS := $(join $(SDK_LIBDIRS),$(SDK_LIBNAMES))
endif

PCHPATH := $(OUTDIR)/stdafx.h.gch

PROJECT_FILES := $(foreach filename,$(PROJECT_FILES),$(wildcard $(filename)))
OBJS := $(subst .cpp,.o, $(PROJECT_FILES))
OBJS := $(subst .c,.o, $(OBJS))
OBJS := $(subst .png,.png.o, $(OBJS))
OBJS := $(subst .glade,.glade.o, $(OBJS))
SUBDIRS := $(dir $(OBJS))
SUBDIRS := $(sort $(SUBDIRS))
SUBDIRS := $(subst ./,, $(SUBDIRS))
SUBDIRS := $(addprefix $(OUTDIR)/,$(SUBDIRS))
OBJS := $(addprefix $(OUTDIR)/,$(OBJS))

#$(info $(OBJS))
#$(info $(SUBDIRS))
#$(info $(SDK_LIBPATHS))
#$(info $(CFLAGS))

all: build_deps build

welcome_msg:
	$(info ----------------------- $(PROJECT_NAME) $(CONFIG) -----------------------)

build_deps:
ifneq ($(PROJECT_TYPE), lib)
	@for dir in $(SDK_DIRS); do $(MAKE) --no-print-directory -C $$dir || exit; done
endif

build: welcome_msg $(OUTDIR) $(SUBDIRS) $(OUTPATH)

clean: clean_deps welcome_msg
	$(info cleaning...)
	@rm -rf $(OUTDIR)

clean_deps:
ifneq ($(PROJECT_TYPE), lib)
	@for dir in $(SDK_DIRS); do $(MAKE) --no-print-directory -C $$dir clean; done
endif

$(OUTDIR):
	@mkdir $(OUTDIR)

$(SUBDIRS):
	@mkdir $@

$(OUTPATH): $(SDK_LIBPATHS) $(PCHPATH) $(OBJS)
ifeq ($(PROJECT_TYPE), lib)
	$(info creating library $(OUTPATH))
	@ar rcs $(OUTPATH) $(OBJS)
else
	$(info linking application $(OUTPATH))
	@$(GPP) $(OBJS) $(SDK_LIBPATHS) -Wl,$(LDFLAGS) $(EXTLIBS) -o $(OUTPATH)
endif

$(PCHPATH): stdafx.h
	$(info stdafx.h (precompiled header))
	@$(GPP) $(CPPFLAGS) -c stdafx.h -o $(PCHPATH)

-include $(subst .o,.d, $(OBJS))

$(OUTDIR)/%.o: %.cpp $(PCHPATH)
	$(info $<)
	@$(GPP) $(CPPFLAGS) -c -MMD $< -o $@

$(OUTDIR)/%.o: %.c
	$(info $<)
	@$(GCC) $(CFLAGS) -c -MMD $< -o $@

$(OUTDIR)/%.png.o: %.png
	$(info $< (resource))
	@$(LD) -r -o $@ -z noexecstack --format=binary $<
	@$(OBJCOPY) --rename-section .data=.rodata,alloc,load,readonly,data,contents $@

$(OUTDIR)/%.glade.o: %.glade
	$(info $< (resource))
	@$(LD) -r -o $@ -z noexecstack --format=binary $<
	@$(OBJCOPY) --rename-section .data=.rodata,alloc,load,readonly,data,contents $@

rebuild: clean all

run: all
	$(OUTPATH)

install: all
	@cp $(OUTPATH) /usr/bin/
	@echo installed

# -----------------------------------------------------------------------------
# Unit test code coverage
# sudo apt install lcov
OTHER_GCDA_DIRS := $(addprefix --directory ,$(SDK_DIRS))

cov: linux-coverage/html/index.html
	xdg-open linux-coverage/html/index.html

linux-coverage/html/index.html: linux-coverage/coverage.info
	genhtml linux-coverage/coverage.info --output-dir linux-coverage/html

# .gcda files should be present. They are created when executing the application.
# Just check one .gcda presence to know if running should be done
linux-coverage/coverage.info: linux-coverage/stdafx.gcda
	lcov --capture --directory linux-coverage $(OTHER_GCDA_DIRS) --output-file linux-coverage/coverage.info

linux-coverage/stdafx.gcda: linux-coverage/$(PROJECT_NAME)
	linux-coverage/$(PROJECT_NAME)
